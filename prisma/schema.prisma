generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//
// ===================== MODELS =====================
//

model User {
  id          String          @id @default(cuid())
  name        String
  email       String          @unique
  password    String
  mobile      String?         @unique
  vpa         String          @unique
  role        Role            @default(USER)
  createdAt   DateTime        @default(now())

  // relations
  accounts     BankAccount[]
  sessions     Session[]
  kyc          Kyc?
  idempotency  IdempotencyKey[]
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Kyc {
  id         String    @id @default(cuid())
  userId     String    @unique
  documentId String
  status     KycStatus @default(PENDING)
  createdAt  DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model BankAccount {
  id          String   @id @default(cuid())
  userId      String
  accountRef  String   @unique
  createdAt   DateTime @default(now())

  // relations
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  ledger    LedgerEntry[]
  balances  AccountBalance[]
  txFrom    Transaction[]   @relation("TxFromAccount")
  txTo      Transaction[]   @relation("TxToAccount")
  disputes  Dispute[]
}

model LedgerEntry {
  id        String    @id @default(cuid())
  accountId String
  txnId     String
  type      LedgerType
  amount    BigInt
  createdAt DateTime  @default(now())

  bankAccount BankAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  transaction Transaction @relation(fields: [txnId], references: [id], onDelete: Cascade)

  @@index([txnId])
}

model Transaction {
  id              String            @id @default(cuid())
  idempotencyKey  String            @unique
  fromAccountId   String?
  toAccountId     String?
  fromVpa         String
  toVpa           String
  amount          BigInt
  status          TransactionStatus @default(PENDING)
  reason          String?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  transactionType TransactionType?

  // relations
  fromAccount   BankAccount?   @relation("TxFromAccount", fields: [fromAccountId], references: [id])
  toAccount     BankAccount?   @relation("TxToAccount", fields: [toAccountId], references: [id])
  ledgerEntries LedgerEntry[]
  disputes      Dispute[]

  @@index([fromVpa, toVpa])
}

model AccountBalance {
  id        String   @id @default(cuid())
  accountId String   @unique
  balance   BigInt   @default(0)
  updatedAt DateTime @updatedAt

  account BankAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
}

model IdempotencyKey {
  id        String   @id @default(cuid())
  userId    String?
  request   Json
  response  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt])
}

model Dispute {
  id        String        @id @default(cuid())
  txnId     String
  accountId String
  reason    String
  status    DisputeStatus @default(OPEN)
  createdAt DateTime      @default(now())

  transaction Transaction @relation(fields: [txnId], references: [id], onDelete: Cascade)
  account     BankAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
}

//
// ===================== ENUMS =====================
//

enum Role {
  USER
  ADMIN
  SUPPORT
}

enum TransactionType {
  DIRECT_DEPOSIT
  TRANSFER
  WITHDRAWAL
  PAYMENT
  REFUND
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

enum LedgerType {
  CREDIT
  DEBIT
}

enum KycStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum DisputeStatus {
  OPEN
  RESOLVED
  REJECTED
}
